# paste this into your ~/.gitconfig
[alias]

	# give me the name of the branch that I'm currently on
	bn = rev-parse --abbrev-ref HEAD

	# list out all of the commits in this branch concisely
	logg = log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(auto)%d%C(reset)'
	logbr = !git --no-pager logg master..HEAD

	# put my new indexed changes into the previous last commit in this branch
	can = commit --amend --no-edit
	ca = commit --amend --no-edit
	fix = commit --amend --no-edit

	# force push
	pf = push --force-with-lease --force-if-includes
	fp = push --force-with-lease --force-if-includes

	# stash current changes with branch name as message, then switch to the provided branch
	sw = "!f() { \
		git stash push -u -m $(git rev-parse --abbrev-ref HEAD) && \
		git switch \"$1\" && \
		stash_id=$(git stash list | grep \"$1\" | head -n 1 | cut -d: -f1); \
		if [ -n \"$stash_id\" ]; then \
		echo applying_stash; \
			git stash apply \"$stash_id\"; \
		fi; \
	}; f"

	# list branches in order of when you last visited them
	recent = "!f() { \
		current=$(git rev-parse --abbrev-ref HEAD); \
		git log -g --date=relative --format='%ad|%gs' \
		| grep 'checkout: moving' \
		| sed 's/|checkout: moving from .* to /|/' \
		| awk -v cur=\"$current\" -F '|' '!seen[$2]++ { \
			if ($2 == cur) { marker=\"*\" } else { marker=\" \" }; \
			printf \"%s %-30s \\033[32m(%s)\\033[0m\\n\", marker, $2, $1; \
		}' \
		| head -n 6; \
	}; f"

	# "skip" files to ignore any changes which I made to them
	skip = "!f() { \
        git update-index --skip-worktree \"$1\" 2>/dev/null && \
        echo \"Skipped $1\" || \
        { \
            G=$(git config --global core.excludesfile || echo ~/.gitignore_global); \
            echo \"File is untracked. To ignore globally run:\"; \
            echo \"  echo \\\"\\\" >> $G && echo \\\"$1\\\" >> $G\"; \
        }; \
    }; f"
	unskip = update-index --no-skip-worktree
	skipped = "!git ls-files -v | grep '^S' | cut -c 3-"
	unskip-all = "!f() { \
		files=$(git ls-files -v | grep '^S' | cut -c 3-); \
		git update-index --no-skip-worktree $files; \
	}; f"

	# make a backup of my existing commits
	backup = "!f() { \
        target=\"backups/$(git rev-parse --abbrev-ref HEAD)/$(echo $RANDOM | git hash-object --stdin | cut -c 1-7)\"; \
        git branch \"$target\" && echo \"Created backup: $target\"; \
    }; f"

	# see what files were involved in a certain commit
	skim = "!git --no-pager show --pretty=\"\" --stat"

	# create an upstream (github) branch
	up = push -u origin HEAD

	# print the top-level folder
	root = rev-parse --show-toplevel

	# clear everything not committed
	wipe = "!git reset --hard HEAD && git clean -fd"
	nuke = "!git reset --hard HEAD && git clean -fdx"

	# search through git log commit messages
	commit-search = "!f() { git log --grep=\"$1\" --format=\"%h\n%s\" | head; }; f"

	# commit
	c = commit -m

	# create a new branch and go to it
	b = checkout -b

    # change a commit message with `git rename <commit-hash> "new commit message"`
    reword = "!f() { \
        if [ \"$#\" -lt 2 ]; then \
            echo 'Usage: git rename <commit> <new message>' >&2; \
            exit 1; \
        fi; \
        commit=\"$1\"; shift; \
        msg=\"$*\"; \
        full=$(git rev-parse \"$commit\") || exit 1; \
        FILTER_BRANCH_SQUELCH_WARNING=1 \
        TARGET_COMMIT=\"$full\" NEW_MSG=\"$msg\" \
            git filter-branch -f --msg-filter ' \
                if [ \"$GIT_COMMIT\" = \"$TARGET_COMMIT\" ]; then \
                    printf \"%s\n\" \"$NEW_MSG\"; \
                else \
                    cat; \
                fi \
            ' HEAD; \
    }; f"

